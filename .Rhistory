UsedIdFeMale <- numeric()
UsedIdMale <- numeric()
# reserve the single persons
if (i!=1 & i!= Ngen){
nMerriedFemale <- round(sum(df_Ngen$sex == "F") *marR_crt)
nMerriedMale <- round(sum(df_Ngen$sex == "M")*marR_crt)
# make sure there are same numbers of merried males and females
if(nMerriedFemale >= nMerriedMale){
nMerriedFemale <- nMerriedMale
} else {
nMerriedMale <- nMerriedFemale
}
# get the number of single males and females
nSingleFemale <- sum(df_Ngen$sex == "F") - nMerriedFemale
nSingleMale <- sum(df_Ngen$sex == "M") - nMerriedMale
# sample single ids from male ids and female ids
UsedIdFemale <- sample(df_Ngen$id[df_Ngen$sex == "F"], nSingleFemale)
print(c("Used F", UsedIdFemale))
UsedIdMale <- sample(df_Ngen$id[df_Ngen$sex == "M"], nSingleMale)
print(c("Used M", UsedIdMale))
UsedId <- c(UsedIdFeMale, UsedIdMale)
# Create spouses
for(j in 1:nrow(df_Ngen)){
if(df_Ngen$id[j] %in% UsedId){
next
}else {
idx <- j+1
if(df_Ngen$sex[j] == "F"){
for (k in idx:nrow(df_Ngen)){
idr <- df_Ngen$id[k]
tgt <- (!(idr %in% UsedId)) & df_Ngen$sex[k]=="M"
if(tgt){
df_Ngen$spt[j] <- df_Ngen$id[k]
df_Ngen$spt[k] <- df_Ngen$id[j]
UsedId <- c(UsedId, df_Ngen$id[j], df_Ngen$id[k])
break
} else {
next
}
}
}else {
for (k in idx:nrow(df_Ngen)){
idr <- df_Ngen$id[k]
tgt <- (!(idr %in% UsedId)) & df_Ngen$sex[k]=="F"
if(tgt){
df_Ngen$spt[j] <- df_Ngen$id[k]
df_Ngen$spt[k] <- df_Ngen$id[j]
UsedId <- c(UsedId, df_Ngen$id[j], df_Ngen$id[k])
break
} else {
next
}
}
}
}
print(UsedId)
}
}
print(df_Ngen)
}
# # Create a vector of gen indexes
# gen_vec <- character(length = 0L)
#
# for(i in 1:length(sizeGens)){
#       gen_vec <- c(gen_vec, rep(i,sizeGens[i]))
# }
# # Create the whole family dataframe
# # Adapted from simfam package by Alejandro Ochoa
# fam <- data.frame(
#       fam = 'fam1', # place in desired order, but there aren't families really
#       # names of individuals in every generation
#       id = paste0( '1-', 1 : sum(sizeGens) ),
#       gen = gen_vec,
#       pat = NA,
#       mat = NA,
#       sex = NA
#       #      ,pheno = 0
# )
return(df_Ngen)
}
x1 <- SimPed()
# 02/07 goal: get the 50% of the function done by next week.
# The goal of this R file is to design a set of functions to simulate "balanced" pedigrees when setting a group of parameters:
# 1) Kids per couple
# 2) Number of generations
# 3) Sex ratio for offspring
# 4) Marriage rate
# 5) Fixed local pedigree pattern: for example, force the 2nd generation to be a pair of twins
## The final function:
# kpc: kids per couple
# Ngen: number of generations
# sexR: sex ratio for offspring
# marR: marriage rate
# balancedSex: if the sex of kids is balanced within a specific generation
# balancedMar: if the married couples are balanced within a specific generation
SimPed <- function(kpc = 3,
Ngen = 4,
sexR = .5,
marR = 2/3,
balancedSex = FALSE,
balancedmar = FALSE
){
# Calculate the expected family size in each generations
sizeGens <- allGens(kpc = kpc, Ngen = Ngen, marR = marR)
famSizeIndex <- 1:sum(sizeGens)
print(sizeGens)
# Let's build the connection within each generation first
for (i in 1: Ngen) {
idGen <- paste(i,"-",1:sizeGens[i],sep = "")
# idGen <- ifelse(i==1,
#                 paste(i,"-",1:sizeGens[i]),
#                 paste(i,"-",sizeGens[i-1]:sizeGens[i]))
### For each generation, create a seperate dataframe
df_Ngen <- data.frame(
fam = rep(paste("fam",i), sizeGens[i], sep = ""),
id = idGen[1:sizeGens[i]],
gen = rep(i, sizeGens[i]),
pat = rep(NA, sizeGens[i]), # father id
mat = rep(NA, sizeGens[i]), # mother id
spt = rep(NA, sizeGens[i]), # spouse id
sex = rep(NA, sizeGens[i])
)
### Let's deal with the sex in each generation first
if(runif(1) > .5){
sexVec1 <- rep("g1",
floor(length(idGen)*sexR))
sexVec2 <- rep("g2",
length(idGen)-length(sexVec1))
sexVec <- sample(c(sexVec1, sexVec2))
sexVec[sexVec=="g1"] <- "M"
sexVec[sexVec=="g2"] <- "F"
} else{
sexVec1 <- rep("g1",
floor(length(idGen)*(1-sexR)))
sexVec2 <- rep("g2",
length(idGen)-length(sexVec1))
sexVec <- sample(c(sexVec1, sexVec2))
sexVec[sexVec=="g1"] <- "F"
sexVec[sexVec=="g2"] <- "M"
}
df_Ngen$sex <- sexVec
print(paste("tiger",i))
# The first generation
if (i==1){
df_Ngen$spt[1] <- df_Ngen$id[2]
df_Ngen$spt[2] <- df_Ngen$id[1]
df_Ngen$sex[1] <- "F"
df_Ngen$sex[2] <- "M"
}
## Connect male and female into couples in each generations
marR_crt <- (1+marR)/2
UsedIdFeMale <- numeric()
UsedIdMale <- numeric()
# reserve the single persons
if (i!=1 & i!= Ngen){
nMerriedFemale <- round(sum(df_Ngen$sex == "F") *marR_crt)
nMerriedMale <- round(sum(df_Ngen$sex == "M")*marR_crt)
# make sure there are same numbers of merried males and females
if(nMerriedFemale >= nMerriedMale){
nMerriedFemale <- nMerriedMale
} else {
nMerriedMale <- nMerriedFemale
}
# get the number of single males and females
nSingleFemale <- sum(df_Ngen$sex == "F") - nMerriedFemale
nSingleMale <- sum(df_Ngen$sex == "M") - nMerriedMale
# sample single ids from male ids and female ids
UsedIdFemale <- sample(df_Ngen$id[df_Ngen$sex == "F"], nSingleFemale)
print(c("Used F", UsedIdFemale))
UsedIdMale <- sample(df_Ngen$id[df_Ngen$sex == "M"], nSingleMale)
print(c("Used M", UsedIdMale))
UsedId <- c(UsedIdFeMale, UsedIdMale)
# Create spouses
for(j in 1:nrow(df_Ngen)){
if(df_Ngen$id[j] %in% UsedId){
next
}else {
idx <- j+1
if(df_Ngen$sex[j] == "F"){
for (k in idx:nrow(df_Ngen)){
idr <- df_Ngen$id[k]
tgt <- (!(idr %in% UsedId)) & df_Ngen$sex[k]=="M"
if(tgt){
df_Ngen$spt[j] <- df_Ngen$id[k]
df_Ngen$spt[k] <- df_Ngen$id[j]
UsedId <- c(UsedId, df_Ngen$id[j], df_Ngen$id[k])
break
} else {
next
}
}
}else {
for (k in idx:nrow(df_Ngen)){
idr <- df_Ngen$id[k]
tgt <- (!(idr %in% UsedId)) & df_Ngen$sex[k]=="F"
if(tgt){
df_Ngen$spt[j] <- df_Ngen$id[k]
df_Ngen$spt[k] <- df_Ngen$id[j]
UsedId <- c(UsedId, df_Ngen$id[j], df_Ngen$id[k])
break
} else {
next
}
}
}
}
print(UsedId)
}
}
print(df_Ngen)
}
# # Create a vector of gen indexes
# gen_vec <- character(length = 0L)
#
# for(i in 1:length(sizeGens)){
#       gen_vec <- c(gen_vec, rep(i,sizeGens[i]))
# }
# # Create the whole family dataframe
# # Adapted from simfam package by Alejandro Ochoa
# fam <- data.frame(
#       fam = 'fam1', # place in desired order, but there aren't families really
#       # names of individuals in every generation
#       id = paste0( '1-', 1 : sum(sizeGens) ),
#       gen = gen_vec,
#       pat = NA,
#       mat = NA,
#       sex = NA
#       #      ,pheno = 0
# )
return(df_Ngen)
}
x1 <- SimPed()
x1 <- SimPed()
x1 <- SimPed()
x1 <- SimPed()
x1 <- SimPed()
x1 <- SimPed()
x1 <- SimPed()
x1 <- SimPed()
x1 <- SimPed()
x1 <- SimPed()
## The final function:
# kpc: kids per couple
# Ngen: number of generations
# sexR: sex ratio for offspring
# marR: marriage rate
# balancedSex: if the sex of kids is balanced within a specific generation
# balancedMar: if the married couples are balanced within a specific generation
SimPed <- function(kpc = 3,
Ngen = 4,
sexR = .5,
marR = 2/3,
balancedSex = FALSE,
balancedmar = FALSE
){
# Calculate the expected family size in each generations
sizeGens <- allGens(kpc = kpc, Ngen = Ngen, marR = marR)
famSizeIndex <- 1:sum(sizeGens)
print(sizeGens)
# Let's build the connection within each generation first
for (i in 1: Ngen) {
idGen <- paste(i,"-",1:sizeGens[i],sep = "")
# idGen <- ifelse(i==1,
#                 paste(i,"-",1:sizeGens[i]),
#                 paste(i,"-",sizeGens[i-1]:sizeGens[i]))
### For each generation, create a seperate dataframe
df_Ngen <- data.frame(
fam = rep(paste("fam",i), sizeGens[i], sep = ""),
id = idGen[1:sizeGens[i]],
gen = rep(i, sizeGens[i]),
pat = rep(NA, sizeGens[i]), # father id
mat = rep(NA, sizeGens[i]), # mother id
spt = rep(NA, sizeGens[i]), # spouse id
sex = rep(NA, sizeGens[i])
)
### Let's deal with the sex in each generation first
if(runif(1) > .5){
sexVec1 <- rep("g1",
floor(length(idGen)*sexR))
sexVec2 <- rep("g2",
length(idGen)-length(sexVec1))
sexVec <- sample(c(sexVec1, sexVec2))
sexVec[sexVec=="g1"] <- "M"
sexVec[sexVec=="g2"] <- "F"
} else{
sexVec1 <- rep("g1",
floor(length(idGen)*(1-sexR)))
sexVec2 <- rep("g2",
length(idGen)-length(sexVec1))
sexVec <- sample(c(sexVec1, sexVec2))
sexVec[sexVec=="g1"] <- "F"
sexVec[sexVec=="g2"] <- "M"
}
df_Ngen$sex <- sexVec
#print(paste("tiger",i))
# The first generation
if (i==1){
df_Ngen$spt[1] <- df_Ngen$id[2]
df_Ngen$spt[2] <- df_Ngen$id[1]
df_Ngen$sex[1] <- "F"
df_Ngen$sex[2] <- "M"
}
## Connect male and female into couples in each generations
marR_crt <- (1+marR)/2
UsedIdFeMale <- numeric()
UsedIdMale <- numeric()
# reserve the single persons
if (i!=1 & i!= Ngen){
nMerriedFemale <- round(sum(df_Ngen$sex == "F") *marR_crt)
nMerriedMale <- round(sum(df_Ngen$sex == "M")*marR_crt)
# make sure there are same numbers of merried males and females
if(nMerriedFemale >= nMerriedMale){
nMerriedFemale <- nMerriedMale
} else {
nMerriedMale <- nMerriedFemale
}
# get the number of single males and females
nSingleFemale <- sum(df_Ngen$sex == "F") - nMerriedFemale
nSingleMale <- sum(df_Ngen$sex == "M") - nMerriedMale
# sample single ids from male ids and female ids
UsedIdFemale <- sample(df_Ngen$id[df_Ngen$sex == "F"], nSingleFemale)
print(c("Used F", UsedIdFemale))
UsedIdMale <- sample(df_Ngen$id[df_Ngen$sex == "M"], nSingleMale)
print(c("Used M", UsedIdMale))
UsedId <- c(UsedIdFeMale, UsedIdMale)
# Create spouses
for(j in 1:nrow(df_Ngen)){
if(df_Ngen$id[j] %in% UsedId){
next
}else {
idx <- j+1
if(df_Ngen$sex[j] == "F"){
for (k in idx:nrow(df_Ngen)){
idr <- df_Ngen$id[k]
tgt <- (!(idr %in% UsedId)) & df_Ngen$sex[k]=="M"
if(tgt){
df_Ngen$spt[j] <- df_Ngen$id[k]
df_Ngen$spt[k] <- df_Ngen$id[j]
UsedId <- c(UsedId, df_Ngen$id[j], df_Ngen$id[k])
break
} else {
next
}
}
}else {
for (k in idx:nrow(df_Ngen)){
idr <- df_Ngen$id[k]
tgt <- (!(idr %in% UsedId)) & df_Ngen$sex[k]=="F"
if(tgt){
df_Ngen$spt[j] <- df_Ngen$id[k]
df_Ngen$spt[k] <- df_Ngen$id[j]
UsedId <- c(UsedId, df_Ngen$id[j], df_Ngen$id[k])
break
} else {
next
}
}
}
}
# print(UsedId)
}
}
if(i == 1) {
df_Fam <- df_Ngen
} else {
df_Fam <- rbind(df_Fam, df_Ngen)
}
print(df_Fam)
}
return(df_Fam)
}
x1 <- SimPed()
x1 <- SimPed()
# 02/07 goal: get the 50% of the function done by next week.
# The goal of this R file is to design a set of functions to simulate "balanced" pedigrees when setting a group of parameters:
# 1) Kids per couple
# 2) Number of generations
# 3) Sex ratio for offspring
# 4) Marriage rate
# 5) Fixed local pedigree pattern: for example, force the 2nd generation to be a pair of twins
## The final function:
# kpc: kids per couple
# Ngen: number of generations
# sexR: sex ratio for offspring
# marR: marriage rate
# balancedSex: if the sex of kids is balanced within a specific generation
# balancedMar: if the married couples are balanced within a specific generation
SimPed <- function(kpc = 3,
Ngen = 4,
sexR = .5,
marR = 2/3,
balancedSex = FALSE,
balancedmar = FALSE
){
# Calculate the expected family size in each generations
sizeGens <- allGens(kpc = kpc, Ngen = Ngen, marR = marR)
famSizeIndex <- 1:sum(sizeGens)
print(sizeGens)
# Let's build the connection within each generation first
for (i in 1: Ngen) {
idGen <- paste(i,"-",1:sizeGens[i],sep = "")
# idGen <- ifelse(i==1,
#                 paste(i,"-",1:sizeGens[i]),
#                 paste(i,"-",sizeGens[i-1]:sizeGens[i]))
### For each generation, create a seperate dataframe
df_Ngen <- data.frame(
fam = rep(paste("fam",1), sizeGens[i], sep = ""),
id = idGen[1:sizeGens[i]],
gen = rep(i, sizeGens[i]),
pat = rep(NA, sizeGens[i]), # father id
mat = rep(NA, sizeGens[i]), # mother id
spt = rep(NA, sizeGens[i]), # spouse id
sex = rep(NA, sizeGens[i])
)
### Let's deal with the sex in each generation first
if(runif(1) > .5){
sexVec1 <- rep("g1",
floor(length(idGen)*sexR))
sexVec2 <- rep("g2",
length(idGen)-length(sexVec1))
sexVec <- sample(c(sexVec1, sexVec2))
sexVec[sexVec=="g1"] <- "M"
sexVec[sexVec=="g2"] <- "F"
} else{
sexVec1 <- rep("g1",
floor(length(idGen)*(1-sexR)))
sexVec2 <- rep("g2",
length(idGen)-length(sexVec1))
sexVec <- sample(c(sexVec1, sexVec2))
sexVec[sexVec=="g1"] <- "F"
sexVec[sexVec=="g2"] <- "M"
}
df_Ngen$sex <- sexVec
#print(paste("tiger",i))
# The first generation
if (i==1){
df_Ngen$spt[1] <- df_Ngen$id[2]
df_Ngen$spt[2] <- df_Ngen$id[1]
df_Ngen$sex[1] <- "F"
df_Ngen$sex[2] <- "M"
}
## Connect male and female into couples in each generations
marR_crt <- (1+marR)/2
UsedIdFeMale <- numeric()
UsedIdMale <- numeric()
# reserve the single persons
if (i!=1 & i!= Ngen){
nMerriedFemale <- round(sum(df_Ngen$sex == "F") *marR_crt)
nMerriedMale <- round(sum(df_Ngen$sex == "M")*marR_crt)
# make sure there are same numbers of merried males and females
if(nMerriedFemale >= nMerriedMale){
nMerriedFemale <- nMerriedMale
} else {
nMerriedMale <- nMerriedFemale
}
# get the number of single males and females
nSingleFemale <- sum(df_Ngen$sex == "F") - nMerriedFemale
nSingleMale <- sum(df_Ngen$sex == "M") - nMerriedMale
# sample single ids from male ids and female ids
UsedIdFemale <- sample(df_Ngen$id[df_Ngen$sex == "F"], nSingleFemale)
print(c("Used F", UsedIdFemale))
UsedIdMale <- sample(df_Ngen$id[df_Ngen$sex == "M"], nSingleMale)
print(c("Used M", UsedIdMale))
UsedId <- c(UsedIdFeMale, UsedIdMale)
# Create spouses
for(j in 1:nrow(df_Ngen)){
if(df_Ngen$id[j] %in% UsedId){
next
}else {
idx <- j+1
if(df_Ngen$sex[j] == "F"){
for (k in idx:nrow(df_Ngen)){
idr <- df_Ngen$id[k]
tgt <- (!(idr %in% UsedId)) & df_Ngen$sex[k]=="M"
if(tgt){
df_Ngen$spt[j] <- df_Ngen$id[k]
df_Ngen$spt[k] <- df_Ngen$id[j]
UsedId <- c(UsedId, df_Ngen$id[j], df_Ngen$id[k])
break
} else {
next
}
}
}else {
for (k in idx:nrow(df_Ngen)){
idr <- df_Ngen$id[k]
tgt <- (!(idr %in% UsedId)) & df_Ngen$sex[k]=="F"
if(tgt){
df_Ngen$spt[j] <- df_Ngen$id[k]
df_Ngen$spt[k] <- df_Ngen$id[j]
UsedId <- c(UsedId, df_Ngen$id[j], df_Ngen$id[k])
break
} else {
next
}
}
}
}
# print(UsedId)
}
}
if(i == 1) {
df_Fam <- df_Ngen
} else {
df_Fam <- rbind(df_Fam, df_Ngen)
}
print(df_Fam)
}
return(df_Fam)
}
x1 <- SimPed()
View(x1)
